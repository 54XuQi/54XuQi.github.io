<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA泛型</title>
      <link href="/2024/10/27/JAVA%E6%B3%9B%E5%9E%8B/"/>
      <url>/2024/10/27/JAVA%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="JAVA-泛型"><a href="#JAVA-泛型" class="headerlink" title="JAVA 泛型"></a>JAVA 泛型</h2><h3 id="1、为什么引入泛型？"><a href="#1、为什么引入泛型？" class="headerlink" title="1、为什么引入泛型？"></a>1、为什么引入泛型？</h3><ul><li>Java当中的generic泛型，相信在初学时各位多少对其都存在一些困惑。其中的K，V，T等等以及通配符时而出现在类中，时而出现在方法里面。</li><li>那么我们又该如何使用Generics泛型这个概念呢？</li><li><strong>在了解泛型之前，首先应该了解在没有泛型之前，我们是如何解决问题的。</strong></li><li>下面展示一段简单的演示代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntegerPrinter</span> &#123;</span><br><span class="line">    Integer content;</span><br><span class="line">    IntegerPrinter(Integer content) &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>假设为我们想要打印一段int类型内容，我们创造了这个类。</li><li>当然，他可以很好的执行功能。</li><li>可如果需求变更，我们需要打印string类型的内容时，就难免需要费些力气。</li><li>再新建一个字符串的Printer:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringPrinter</span> &#123;</span><br><span class="line">    String content;</span><br><span class="line">    StringPrinter(String content) &#123;</span><br><span class="line">         <span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">         System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种解法会给代码带来重复性，也给后来的拓展留下麻烦。</li><li>因此Java引入了Generic泛型这个概念。</li><li><strong>合适情况</strong>下，只需一个类，就可以处理之后的所有<strong>类型</strong>。</li></ul><h3 id="2、泛型类-Generic-Classes"><a href="#2、泛型类-Generic-Classes" class="headerlink" title="2、泛型类 Generic Classes"></a>2、泛型类 Generic Classes</h3><ul><li><strong>如何来声明一个generic的类呢？</strong></li><li>还是以之前的例子，我们可以将其进一步抽象为Printer类。</li><li>此处放出修改后的类Printer：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &lt;T&gt; &#123;</span><br><span class="line">    T content;</span><br><span class="line">    Printer(T content) &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>注意：</strong></p><ul><li>我们在<strong>类名</strong>与<strong>函数体</strong>间加入了 T。</li><li><strong>占位符</strong>T代表这里可以这个类中可以传入<strong>任何参数</strong>。</li><li>这里的T，也可以是K，V或其他的任何字符。</li><li>具体此处的T是什么类型，是由外界调用时决定的。</li><li>可以理解成，它将参数本身作为一个特殊的参数传入其中。</li></ul></li><li>这里提供Main方法中使用Printer类分别打印int类型和string类型的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Printer&lt;Integer&gt; printer1 = <span class="keyword">new</span> <span class="title class_">Printer</span>( <span class="number">123</span> ) ;</span><br><span class="line">        printer1.print();</span><br><span class="line">        Printer&lt;String&gt; printer2 = <span class="keyword">new</span> <span class="title class_">Printer</span>( <span class="string">&quot;Hello World&quot;</span> ) ;</span><br><span class="line">        printer2.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里需要注意尖括号内的类型不能是像int、float一类的基本类型。</li><li>而是经过包装后的类型。</li><li>此处列出Java的基本类型与包装类型。</li></ul><div class="table-container"><table><thead><tr><th>基本类型</th><th>包装类型</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr></tbody></table></div><ul><li>至于<strong>原因</strong>：</li><li>基本类型不是Object的子类。</li><li>泛型是通过Object来实现的。</li></ul><h3 id="3、类型参数的约束"><a href="#3、类型参数的约束" class="headerlink" title="3、类型参数的约束"></a>3、类型参数的约束</h3><ul><li>在实际做项目时</li><li>可能会发现先前的内容并不能满足我们</li><li>这时候我们可以对泛型做一些约束</li><li>什么意思呢？</li><li>这里先简单创建类Vehicle,Bus,Car</li><li>类Bus,Car继承Vehicle</li><li><p>再以先前的Printer类举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Printer</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Vehicle</span>&gt; &#123;</span><br><span class="line">    T content;</span><br><span class="line">    Printer(T content) &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在最前面尖括号内的后加入了 <strong>extends Vehicle</strong></li><li>这时会发现先前的<strong>Main</strong>方法出错了</li><li>显然Main中的String,Integer<strong>并非</strong>Vehicle 的子类</li><li><p>稍作修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Printer&lt;Car&gt; printer1 = <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="keyword">new</span> <span class="title class_">Car</span>()) ;</span><br><span class="line">printer1.print();</span><br><span class="line">Printer&lt;Bus&gt; printer2 = <span class="keyword">new</span> <span class="title class_">Printer</span>(<span class="keyword">new</span> <span class="title class_">Bus</span>() ) ;</span><br><span class="line">printer2.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>成功运行</li><li>在Java中，这被称作<strong>bounded generics</strong></li><li>即有界限的泛型</li><li>值得注意的是若用接口来约束</li><li><strong>仍应使用extends</strong></li><li>此处以先前的Printer举例</li><li>若现要求用同时用interface与class来约束</li><li>尖括号内应为<strong>T extends Vehicle &amp; Thing</strong></li><li><p>仅需用<strong>&amp;</strong>来连接</p><ul><li><strong>注意：</strong><ul><li>如果要约束参数为class子类且实现interface</li><li>格式必须是class &amp; interface</li><li>颠倒时编译会报错</li></ul></li></ul></li><li>如此做有个好处</li><li>既然传入的类参数都是<strong>继承自Vehicle</strong></li><li><p>也就<strong>意味传入的参数变量其实获得所有Vehicle的方法</strong></p><h3 id="4、类型安全-Type-safe"><a href="#4、类型安全-Type-safe" class="headerlink" title="4、类型安全 Type-safe"></a>4、类型安全 Type-safe</h3></li><li>其实平时大家就在有意无意的使用Java中的泛型</li><li>最常见的应该就是Collection Framework(集合框架)</li><li>以<strong>List</strong>举例</li><li>如果我们用其存放Interger类型数据为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果我们想将其类型改为String则为</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>有时我们会想</li><li>能否在一个列表里存放任何元素呢</li><li>由于Integer和String都为Object的子类</li><li>我们试着将其改为Object</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>经过修改，它很成功的完成了任务</li><li>但在实际编程中，非常不建议这么做</li><li>这会带来一个type-safe的问题</li><li>这里举个例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">item</span> <span class="operator">=</span> (String) list.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(item);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们取刚才数组的第二个，并用强制类型转换转换其为String</li><li>此时编译器并不会报错</li><li>但在点击运行时报了<strong>ClassCastException错误</strong></li><li>这是因为Java中</li><li>泛型的工作方式是在<strong>编译阶段进行类型检查</strong>的</li><li>而不是在运行阶段</li></ul><h3 id="5、泛型方法-Generic-Methods"><a href="#5、泛型方法-Generic-Methods" class="headerlink" title="5、泛型方法 Generic Methods"></a>5、泛型方法 Generic Methods</h3><ul><li>泛型也经常用在函数上</li><li>我们称之为generic method</li><li>假设现在我们有这样一个需求</li><li>我们需要写一个print的方法</li><li>去打印任意的变量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T content)</span> &#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过在<strong>返回值类型前</strong>加入 &lt;<strong>T></strong></li><li>让系统知晓此处的T是generic类型</li><li>这时我们就可以打印任何变量了</li><li>同理我们也可以像先前类中对泛型的约束一样</li><li>使用extens来对其限制</li><li>当然这里我们也可以传入多个参数</li><li>比方说</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T , K&gt; <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(T content1 , K content2)</span> &#123;</span><br><span class="line">    System.out.println(content1);</span><br><span class="line">System.out.println(content2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、通配符-Wildcard"><a href="#6、通配符-Wildcard" class="headerlink" title="6、通配符 Wildcard"></a>6、通配符 Wildcard</h3><ul><li>假如现在我们需要一个方法</li><li>它能够打印存放有Integer元素的List</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;Integer&gt; content)</span> &#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果之后需求变更</li><li>转为放有Sting元素的List</li><li>又需要将其中的Integer改为String</li><li>可能这时有人会想像先前一样将其改为Object</li><li>此时我们试着使用print</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">print(list);</span><br></pre></td></tr></table></figure><ul><li>发现编译器此时会报错</li><li>这是因为虽然String是Object的子类</li><li>但List <code>&lt;String&gt;</code>却不是List <code>&lt;Object&gt;</code>的子类</li><li>那这种情况下我们该怎么办呢？</li><li>我们引入一个新的概念<strong>Wildcard</strong>(通配符)</li><li>符号用?号来表达</li><li>更改先前的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; content)</span> &#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>报错消失了</li><li>代表它可以<strong>匹配所有的类型</strong></li><li>而不是使用刚才的方法</li><li>那如果我们不想匹配所有的类型</li><li>而是做一些类型上的约束</li><li>又该如何处理呢</li><li>我们可以仿照之前的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;? extends Vehicle&gt; content)</span> &#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用extends之后这里类型必须为Vehicle的子类</li><li>通配符有一类被称为lower bounded wildcard(下界通配符)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;? <span class="built_in">super</span> Car&gt; content)</span> &#123;</span><br><span class="line">    System.out.println(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>它是用<strong>super</strong>来约束的</li><li><p>与extends相反，传入的参数类型必须为父类</p><p>ps：第一次写教学，如有失误，还望海涵。（当然，也欢迎提出修改及建设性建议，本人了解后不一定会改）</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 学习 </tag>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>降临</title>
      <link href="/2023/10/28/%E7%BD%91%E7%AB%99%E8%AF%9E%E7%94%9F/"/>
      <url>/2023/10/28/%E7%BD%91%E7%AB%99%E8%AF%9E%E7%94%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="网站诞生"><a href="#网站诞生" class="headerlink" title="网站诞生"></a>网站诞生</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
